<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>3Dパチンコ Physics Test</title>
    <style>
        /* ボディ全体のスタイルをリセット */
        body {
            margin: 0;
            overflow: hidden;
            /* スクロールバーを非表示にする */
        }

        /* キャンバスのスタイル */
        #myCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ボタンのスタイル */
        #launchButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>

<body>

    <!-- 3D描画領域となるキャンバス -->
    <canvas id="myCanvas"></canvas>

    <!-- ボールを打ち上げるためのボタン -->
    <button id="launchButton">ボールを落とす</button>

    <!-- ES Moduleのimportmapを使用してライブラリを読み込む -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <!-- メインのプログラム -->
    <script type="module">
        //==================================================
        // ライブラリのインポート
        //==================================================
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        //==================================================
        // 初期化処理
        //==================================================

        // Three.jsのシーンを作成
        const scene = new THREE.Scene();

        // Cannon.jsの物理ワールドを作成
        const world = new CANNON.World();
        // 重力を設定（視認性のため少し強めに設定）
        world.gravity.set(0, -30, 0);

        // パフォーマンス改善：動きの少ない物体の物理計算を休止させる機能を有効化
        world.allowSleep = true;


        //==================================================
        // カメラの設定
        //==================================================
        // 真横から見るために、画角を調整し、遠近感のない平行投影カメラを使用
        const aspect = window.innerWidth / window.innerHeight;
        const frustumSize = 20;
        const camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
        // カメラをX軸プラス方向の真横に配置（真横視点）
        camera.position.set(30, 0, 0);
        // カメラの注視点を原点に設定（真横から原点を見る）
        camera.lookAt(0, 0, 0);


        //==================================================
        // レンダラーの設定
        //==================================================
        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#myCanvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);


        //==================================================
        // 光源の設定
        //==================================================
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        // 真横ビューに合わせて光源も横方向から当てる
        directionalLight.position.set(30, 10, 0);
        scene.add(directionalLight);


        //==================================================
        // 物理マテリアルの設定
        //==================================================
        const sphereMaterialCannon = new CANNON.Material('sphere');
        const wallMaterialCannon = new CANNON.Material('wall');

        // 壁とボールの接触挙動
        const wallContactMaterial = new CANNON.ContactMaterial(wallMaterialCannon, sphereMaterialCannon, { friction: 0.3, restitution: 0.6 });
        world.addContactMaterial(wallContactMaterial);

        // （釘は削除されたため、ここに追加の接触材はありません）


        //==================================================
        // 物理オブジェクトと表示オブジェクトの作成
        //==================================================
        const objectsToUpdate = [];

        //--- 壁 (Wall) ---
        // 物理的な壁（盤面）を定義
        const wallBody = new CANNON.Body({ mass: 0, material: wallMaterialCannon });
        wallBody.addShape(new CANNON.Plane());
        // 壁を垂直に立てる（X軸周りの回転を0にする）
        const angle = 0; // 0度
        wallBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), angle);
        world.addBody(wallBody);

        // 見た目上の壁（盤面）
        const wallMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(20, 20),
            new THREE.MeshStandardMaterial({ color: 0x888888, side: THREE.DoubleSide })
        );
        wallMesh.quaternion.copy(wallBody.quaternion);
        scene.add(wallMesh);


        // 釘は削除されました


        //--- ボール (Sphere) ---
        const sphereRadius = 0.5;
        const sphereBody = new CANNON.Body({
            mass: 1,
            // 釘の真上に配置
            // 釘を削除したため、Zは中央(0)に置く
            position: new CANNON.Vec3(0, 8, 0),
            shape: new CANNON.Sphere(sphereRadius),
            material: sphereMaterialCannon,
            // スリープを無効にして初期落下が確実に始まるようにする
            allowSleep: false,
        });
        world.addBody(sphereBody);

        // Y軸のみ物理挙動を許可（X/Z移動を物理的に固定）
        if (sphereBody.linearFactor) {
            sphereBody.linearFactor.set(0, 1, 0);
        } else {
            // もし linearFactor が未定義なら直接プロパティをセット
            sphereBody.linearFactor = new CANNON.Vec3(0, 1, 0);
        }

        const sphereMesh = new THREE.Mesh(
            new THREE.SphereGeometry(sphereRadius),
            new THREE.MeshStandardMaterial({ color: 'red', metalness: 0.5, roughness: 0.4 })
        );
        // 初期表示で物理ボディとメッシュの位置を一致させる
        sphereMesh.position.copy(sphereBody.position);
        objectsToUpdate.push({ mesh: sphereMesh, body: sphereBody });
        scene.add(sphereMesh);


        //==================================================
        // イベントリスナー
        //==================================================
        const launchButton = document.getElementById('launchButton');
        launchButton.addEventListener('click', () => {
            // 既存の速度と角速度をリセット
            sphereBody.velocity.set(0, 0, 0);
            sphereBody.angularVelocity.set(0, 0, 0);
            // ボールを開始位置（釘の真上）に再配置
            sphereBody.position.set(0, 8, 0);
            // スリープ状態から強制的に復帰させる
            sphereBody.wakeUp();
        });

        window.addEventListener('resize', () => {
            // カメラのアスペクト比を更新
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            // レンダラーのサイズを更新
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        //==================================================
        // アニメーションループ
        //==================================================
        const clock = new THREE.Clock();
        let oldElapsedTime = 0;
        // デバッグ用：垂直速度ログのタイマ
        let debugElapsed = 0;

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            const deltaTime = elapsedTime - oldElapsedTime;
            oldElapsedTime = elapsedTime;

            // 物理ワールドの計算を進める
            world.step(1 / 60, deltaTime, 3);

            // デバッグ出力：0.5秒ごとに垂直速度をログ
            debugElapsed += deltaTime;
            if (debugElapsed > 0.5) {
                if (sphereBody && sphereBody.velocity) {
                    console.log('sphere vy=', sphereBody.velocity.y.toFixed(3));
                }
                debugElapsed = 0;
            }

            // Three.jsのオブジェクトを物理ボディに同期
            for (const obj of objectsToUpdate) {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            }

            // レンダリング
            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>

</html>