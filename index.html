<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>3Dパチンコ Physics Test</title>
    <style>
        /* ボディ全体のスタイルをリセット */
        body {
            margin: 0;
            overflow: hidden;
            /* スクロールバーを非表示にする */
        }

        /* キャンバスのスタイル */
        #myCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ボタンのスタイル */
        #launchButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }

        .sim-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 8px;
        }

        .sim-controls button {
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
        }

    </style>
</head>

<body>

    <!-- 3D描画領域となるキャンバス -->
    <canvas id="myCanvas"></canvas>

    <!-- ボールを打ち上げるためのボタン -->
    <button id="launchButton">ボールを落とす</button>
    <!-- シミュレーション制御ボタン -->
    <div class="sim-controls">
        <button id="playBtn">再生</button>
        <button id="pauseBtn">停止</button>
        <button id="resetBtn">リセット</button>
        <button id="resetViewBtn">視点リセット</button>
    </div>

    <!-- ES Moduleのimportmapを使用してライブラリを読み込む -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <!-- メインのプログラム -->
    <script type="module">
        //==================================================
        // ライブラリのインポート
        //==================================================
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        //==================================================
        // 初期化処理
        //==================================================

        // Three.jsのシーンを作成
        const scene = new THREE.Scene();

        // Cannon.jsの物理ワールドを作成
        const world = new CANNON.World();
        // 重力を設定（地球標準の値に戻す）
        world.gravity.set(0, -9.82, 0);

        // パフォーマンス改善：動きの少ない物体の物理計算を休止させる機能を有効化
        world.allowSleep = true;


        //==================================================
        // カメラの設定
        //==================================================
        // 真横から見るために、画角を調整し、遠近感のない平行投影カメラを使用
        const aspect = window.innerWidth / window.innerHeight;
        const frustumSize = 20;
        const camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000);
        // 斜め上から見下ろす位置にカメラを配置
        camera.position.set(20, 12, 20);
        // カメラの注視点を原点に設定（斜め上から原点を見る）
        camera.lookAt(0, 0, 0);


        //==================================================
        // レンダラーの設定
        //==================================================
        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#myCanvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // カメラ操作用コントロール（ドラッグで視点移動）
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.07;
        controls.enablePan = true;
        controls.target.set(0, 0, 0);

        // 初期視点を保存（リセット用）
        const initialCameraPos = camera.position.clone();
        const initialTarget = controls.target.clone();


        //==================================================
        // 光源の設定
        //==================================================
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        // 真横ビューに合わせて光源も横方向から当てる
        directionalLight.position.set(30, 10, 0);
        scene.add(directionalLight);

        //==================================================
        // 物理マテリアルの設定
        //==================================================
        const sphereMaterialCannon = new CANNON.Material('sphere');


        // （釘は削除されたため、ここに追加の接触材はありません）


        //==================================================
        // 物理オブジェクトと表示オブジェクトの作成
        //==================================================
        const objectsToUpdate = [];

        // 壁（plane と backWall）はすべて削除済み


        // 釘は削除されました


        //--- ボール (Sphere) ---
        const sphereRadius = 0.5;
        const sphereBody = new CANNON.Body({
            mass: 1,
            position: new CANNON.Vec3(0, 8, 0),
            shape: new CANNON.Sphere(sphereRadius),
            material: sphereMaterialCannon,
            // スリープを無効にして初期落下が確実に始まるようにする
            allowSleep: false,
        });
        world.addBody(sphereBody);

        // Y軸のみ物理挙動を許可（X/Z移動を物理的に固定）
        if (sphereBody.linearFactor) {
            sphereBody.linearFactor.set(0, 1, 0);
        } else {
            sphereBody.linearFactor = new CANNON.Vec3(0, 1, 0);
        }

        const sphereMesh = new THREE.Mesh(
            new THREE.SphereGeometry(sphereRadius),
            new THREE.MeshStandardMaterial({ color: 'red', metalness: 0.5, roughness: 0.4 })
        );
        // 初期表示で物理ボディとメッシュの位置を一致させる
        sphereMesh.position.copy(sphereBody.position);
        objectsToUpdate.push({ mesh: sphereMesh, body: sphereBody });
        scene.add(sphereMesh);

        // シミュレーション制御
        let isPaused = false;
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');

        playBtn.addEventListener('click', () => {
            isPaused = false;
        });
        pauseBtn.addEventListener('click', () => {
            isPaused = true;
        });
        resetBtn.addEventListener('click', () => {
            // 停止して位置と速度を初期化
            isPaused = true;
            sphereBody.velocity.set(0, 0, 0);
            sphereBody.angularVelocity.set(0, 0, 0);
            sphereBody.position.set(0, 8, 0);
            sphereBody.quaternion.set(0, 0, 0, 1);
            // Three.js メッシュも同期
            for (const obj of objectsToUpdate) {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            }
        });
        const resetViewBtn = document.getElementById('resetViewBtn');
        resetViewBtn.addEventListener('click', () => {
            // カメラ位置とコントロールターゲットを初期値に戻す
            camera.position.copy(initialCameraPos);
            controls.target.copy(initialTarget);
            controls.update();
        });

        window.addEventListener('resize', () => {
            // カメラのアスペクト比を更新
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            // レンダラーのサイズを更新
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        //==================================================
        // アニメーションループ
        //==================================================
        const clock = new THREE.Clock();
        let oldElapsedTime = 0;
        // デバッグ用：垂直速度ログのタイマ
        let debugElapsed = 0;

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            const deltaTime = elapsedTime - oldElapsedTime;
            oldElapsedTime = elapsedTime;

            // 物理ワールドの計算を進める（停止中はスキップ）
            if (!isPaused) {
                world.step(1 / 60, deltaTime, 3);
            }

            // デバッグ出力：0.5秒ごとに垂直速度をログ（停止中は出力しない）
            debugElapsed += deltaTime;
            if (debugElapsed > 0.5) {
                if (!isPaused && sphereBody && sphereBody.velocity) {
                    console.log('sphere vy=', sphereBody.velocity.y.toFixed(3));
                }
                debugElapsed = 0;
            }

            // Three.jsのオブジェクトを物理ボディに同期
            for (const obj of objectsToUpdate) {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            }

            // カメラコントロールの更新（dampingが有効なら毎フレーム必要）
            if (typeof controls !== 'undefined') controls.update();

            // レンダリング
            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>

</html>