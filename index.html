<!DOCTYPE html>
<html>

<head>
	<title>Matter.js パチンコシミュレーター</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		body {
			margin: 0;
			overflow: hidden;
			background-color: #1a1a1a;
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100vh;
			font-family: 'Helvetica Neue', sans-serif;
		}

		.game-container {
			position: relative;
			width: 450px;
			height: 700px;
			background: linear-gradient(135deg, #2c3e50, #34495e);
			border-radius: 20px;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), inset 0 0 15px rgba(0, 0, 0, 0.4);
			border: 5px solid #bdc3c7;
			overflow: hidden;
		}

		canvas {
			display: block;
			background-color: transparent;
		}

		.ui-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			/* UIが物理演算の邪魔をしないように */
			display: flex;
			flex-direction: column;
			justify-content: flex-end;
			/* Align items to the bottom */
			align-items: center;
			padding: 20px;
			box-sizing: border-box;
		}

		.message-box {
			position: absolute;
			top: 20px;
			background-color: rgba(0, 0, 0, 0.7);
			color: #f1c40f;
			padding: 10px 15px;
			border-radius: 8px;
			font-size: 18px;
			font-weight: bold;
			border: 2px solid #f1c40f;
			visibility: hidden;
			/* Initially hidden */
		}

		#drop-button {
			pointer-events: all;
			/* ボタンだけクリックできるように */
			padding: 15px 40px;
			font-size: 20px;
			font-weight: bold;
			color: white;
			background: linear-gradient(145deg, #2980b9, #3498db);
			border: none;
			border-radius: 50px;
			cursor: pointer;
			box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
			transition: all 0.2s ease;
			margin-bottom: 10px;
			user-select: none;
			/* ボタンのテキストを選択できないように */
		}

		#drop-button:hover {
			transform: translateY(-2px);
			box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
		}

		#drop-button:active {
			transform: translateY(1px) scale(0.98);
			box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
		}
	</style>
</head>

<body>
	<div class="game-container">
		<canvas id="pachinko-canvas"></canvas>
		<div class="ui-container">
			<div class="message-box" id="message-box">メッセージ</div>
			<button id="drop-button">落下</button>
		</div>
	</div>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
	<script>
		// --- Matter.js モジュールの準備 ---
		const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;

		// --- ゲーム設定 ---
		const GAME_WIDTH = 450;
		const GAME_HEIGHT = 700;
		const globalXOffset = -5; // ★変更点: 全体を左に寄せるためのオフセット
		let dropInterval = null;

		// --- UI要素の取得 ---
		const dropButton = document.getElementById('drop-button');
		const messageBox = document.getElementById('message-box');

		// 投下数 / 役物ヒット数カウンタ
		let totalDrops = 0;
		let orangeHits = 0; // startChucker
		let blueHits = 0;   // tulip

		// 比率表示要素を作る
		const statsEl = document.createElement('div');
		statsEl.style.pointerEvents = 'none';
		statsEl.style.position = 'absolute';
		statsEl.style.bottom = '20px';
		statsEl.style.right = '20px';
		statsEl.style.padding = '6px 10px';
		statsEl.style.background = 'rgba(0,0,0,0.6)';
		statsEl.style.color = 'white';
		statsEl.style.borderRadius = '6px';
		statsEl.style.fontSize = '14px';
		statsEl.textContent = '投入:0  当たり:0  比率:0%';
		document.querySelector('.game-container').appendChild(statsEl);

		// --- Matter.js エンジンの初期化 ---
		const engine = Engine.create({
			gravity: { y: 0.6 }
		});
		const world = engine.world;

		const render = Render.create({
			canvas: document.getElementById('pachinko-canvas'),
			engine: engine,
			options: {
				width: GAME_WIDTH,
				height: GAME_HEIGHT,
				wireframes: false,
				background: 'transparent'
			}
		});
		Render.run(render);
		const runner = Runner.create();
		Runner.run(runner, engine);

		// --- 壁の作成（床なし） ---
		const wallOptions = { isStatic: true, render: { visible: false } };
		Composite.add(world, [
			Bodies.rectangle(GAME_WIDTH, GAME_HEIGHT / 2, 20, GAME_HEIGHT, wallOptions), // 右
			Bodies.rectangle(0, GAME_HEIGHT / 2, 20, GAME_HEIGHT, wallOptions)      // 左
		]);

		// 左右の壁を左右対称に再配置
		// 調整: 端の釘（最外列）にぴったり付くように内側へ寄せる
		const guideWallOffset = 30;
		Composite.add(world, [
			Bodies.rectangle(guideWallOffset + globalXOffset, 450, 10, 500, { isStatic: true, angle: -0.2, render: { fillStyle: '#95a5a6' } }),
			Bodies.rectangle(GAME_WIDTH - guideWallOffset + globalXOffset, 450, 10, 500, { isStatic: true, angle: 0.2, render: { fillStyle: '#95a5a6' } })
		]);


		// --- 釘の森を生成 (中央揃えに調整) ---
		const pegs = [];
		const pegOptions = {
			isStatic: true, label: 'peg', restitution: 0.8, friction: 0.05,
			render: { fillStyle: '#bdc3c7' }
		};

		const spacing = 35;

		// 画面内上部に追加の釘行を挿入（画面の一番上付近）
		// これにより、玉は上で早めに拡散されやすくなる
		// 上段 (y = 20)
		{
			const topY = 20;
			const cols = 9;
			const rowWidth = (cols - 1) * spacing;
			const xOffset = (GAME_WIDTH - rowWidth) / 2 + globalXOffset;
			for (let col = 0; col < cols; col++) {
				const x = xOffset + col * spacing;
				pegs.push(Bodies.circle(x, topY, 4, pegOptions));
			}
		}
		// 中段 (y = 50)
		{
			const topY = 50;
			const cols = 8;
			const rowWidth = (cols - 1) * spacing;
			const xOffset = (GAME_WIDTH - rowWidth) / 2 + globalXOffset;
			for (let col = 0; col < cols; col++) {
				const x = xOffset + col * spacing;
				pegs.push(Bodies.circle(x, topY, 4, pegOptions));
			}
		}

		const rows = 18;

		for (let row = 0; row < rows; row++) {
			const y = 80 + row * 30;

			if (row % 2 === 0) { // 偶数行 (0, 2, 4...)
				const cols = 8;
				const rowWidth = (cols - 1) * spacing;
				const xOffset = (GAME_WIDTH - rowWidth) / 2 + globalXOffset; // ★変更点
				for (let col = 0; col < cols; col++) {
					const x = xOffset + col * spacing;
					pegs.push(Bodies.circle(x, y, 4, pegOptions));
				}
			} else { // 奇数行 (1, 3, 5...)
				const cols = 9;
				const rowWidth = (cols - 1) * spacing;
				const xOffset = (GAME_WIDTH - rowWidth) / 2 + globalXOffset; // ★変更点
				for (let col = 0; col < cols; col++) {
					const x = xOffset + col * spacing;
					pegs.push(Bodies.circle(x, y, 4, pegOptions));
				}
			}
		}
		Composite.add(world, pegs);

		// 役物周りの追加ペグ（左右対称） - 直接入りづらくするガードを追加
		// 中央のstartChucker上部に小さなバリアを作る
		const extraPegs = [];
		const centerX = GAME_WIDTH / 2 + globalXOffset;
		const barrierY = 540; // startChucker (y=570) の少し上
		const barrierSpacing = 30;
		// 中央バリア: 中央はあえて空けて通路を残す
		for (let i = -1; i <= 1; i++) {
			if (i === 0) continue; // 真ん中は開ける
			extraPegs.push(Bodies.circle(centerX + i * barrierSpacing, barrierY, 5, pegOptions));
		}
		// 以前追加した密集バリアは強すぎたため削除（入らない問題の原因）
		// 代わりに中央バリアを少し散らして隙間を残す
		for (let i = -2; i <= 2; i++) {
			if (i % 2 === 0) continue; // 間隔を空ける
			extraPegs.push(Bodies.circle(centerX + i * (barrierSpacing / 1.5), barrierY + 10, 5, pegOptions));
		}

		// チューリップ周りの左右に小さなガードを置く
		const tulipY = 430; // tulip の少し上
		const tulipLeftX = 120 + globalXOffset;
		const tulipRightX = GAME_WIDTH - 120 + globalXOffset;
		const tulipGuardOffset = 18;
		extraPegs.push(Bodies.circle(tulipLeftX - tulipGuardOffset, tulipY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipLeftX + tulipGuardOffset, tulipY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipRightX - tulipGuardOffset, tulipY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipRightX + tulipGuardOffset, tulipY, 5, pegOptions));
		// チューリップ周辺の追加ディフレクタ: 少し外側へ移動して入口を確保
		const tulipUpperY = tulipY - 20;
		extraPegs.push(Bodies.circle(tulipLeftX - 40, tulipUpperY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipLeftX + 40, tulipUpperY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipRightX - 40, tulipUpperY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipRightX + 40, tulipUpperY, 5, pegOptions));
		// 外側のガードは少しだけ外側に置いて、完全に塞がない
		extraPegs.push(Bodies.circle(tulipLeftX - 70, tulipY - 8, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipRightX + 70, tulipY - 8, 5, pegOptions));

		Composite.add(world, extraPegs);

		// --- 風車（回転障害）の作成: 複合ボディを回転させて玉を妨害 ---
		const windmills = [];
		function createWindmill(cx, cy, blades = 4, radius = 70, bladeW = 8, bladeH = 60, speed = 0.06, color = '#f39c12') {
			const parts = [];
			// ハブ
			const hub = Bodies.circle(cx, cy, 6, { isStatic: true, restitution: 0.8, render: { fillStyle: '#7f8c8d' } });
			parts.push(hub);
			for (let i = 0; i < blades; i++) {
				const angle = (i / blades) * Math.PI * 2;
				const bx = cx + Math.cos(angle) * (radius / 2);
				const by = cy + Math.sin(angle) * (radius / 2);
				const blade = Bodies.rectangle(bx, by, bladeH, bladeW, { isStatic: true, restitution: 0.8, render: { fillStyle: color } });
				Body.setAngle(blade, angle);
				parts.push(blade);
			}
			const compound = Body.create({ parts: parts, isStatic: true, label: 'windmill' });
			Composite.add(world, compound);
			windmills.push({ body: compound, speed });
		}

		// 風車を左右対称に配置
		const centerXWind = GAME_WIDTH / 2 + globalXOffset;
		// 直径を小さくし、回転方向を逆にする
		createWindmill(centerXWind - 80, 320, 4, 40, 8, 40, -0.08, '#f39c12');
		createWindmill(centerXWind + 80, 320, 4, 40, 8, 40, 0.08, '#f39c12');
		// startChucker の真上に小さな中央風車を追加
		// 中央風車（少し大きめに）
		// 中央風車を少し上に移動
		createWindmill(centerXWind, 470, 4, 40, 6, 40, 0.12, '#f39c12');
		// 中央風車をマーク（最後に追加されたもの）
		if (windmills.length) windmills[windmills.length - 1].isCenter = true;

		// 回転を毎フレーム適用
		Events.on(engine, 'beforeUpdate', () => {
			windmills.forEach(w => {
				Body.setAngle(w.body, w.body.angle + w.speed);
			});

			// flap を滑らかに移動
			if (typeof flap !== 'undefined') {
				const currentY = flap.position.y;
				const dy = flapTargetY - currentY;
				if (Math.abs(dy) > 0.5) {
					const newY = currentY + dy * 0.25;
					Body.setPosition(flap, { x: flapX, y: newY });
				}
			}
		});

		// へその風車の回転方向を1秒毎に逆転
		setInterval(() => {
			const cw = windmills.find(w => w.isCenter);
			if (cw) cw.speed = -cw.speed;
		}, 500);

		// --- 役物（やくもの）の作成 ---
		// startChucker を少し小さく下げる
		const startChucker = Bodies.rectangle(GAME_WIDTH / 2 + globalXOffset, 580, 36, 10, { // ★変更点
			isStatic: true, isSensor: true, label: 'startChucker', render: { fillStyle: '#e67e22' }
		});
		// チューリップ幅を縮小
		const tulipLeft = Bodies.rectangle(120 + globalXOffset, 450, 32, 10, { // ★変更点
			isStatic: true, isSensor: true, label: 'tulip', render: { fillStyle: '#3498db' }
		});
		const tulipRight = Bodies.rectangle(GAME_WIDTH - 120 + globalXOffset, 450, 32, 10, { // ★変更点
			isStatic: true, isSensor: true, label: 'tulip', render: { fillStyle: '#3498db' }
		});
		Composite.add(world, [startChucker, tulipLeft, tulipRight]);

		// 役物左右のフェンス（ガイド）を追加して横からの侵入を物理的に防ぐ
		const fenceHeight = 40;
		const fenceThickness = 6;
		// startChucker の左右フェンス
		const fenceOffsetX = 26;
		const leftFence = Bodies.rectangle((GAME_WIDTH / 2 + globalXOffset) - fenceOffsetX, 560, fenceThickness, fenceHeight, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		const rightFence = Bodies.rectangle((GAME_WIDTH / 2 + globalXOffset) + fenceOffsetX, 560, fenceThickness, fenceHeight, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		// チューリップ左右にもフェンス（入口の幅を限定）
		const tulipFenceY = 450;
		const tulipFenceOffset = 22;
		const tulipLeftFenceL = Bodies.rectangle(tulipLeft.position.x - tulipFenceOffset, tulipFenceY, fenceThickness, 36, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		const tulipLeftFenceR = Bodies.rectangle(tulipLeft.position.x + tulipFenceOffset, tulipFenceY, fenceThickness, 36, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		const tulipRightFenceL = Bodies.rectangle(tulipRight.position.x - tulipFenceOffset, tulipFenceY, fenceThickness, 36, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		const tulipRightFenceR = Bodies.rectangle(tulipRight.position.x + tulipFenceOffset, tulipFenceY, fenceThickness, 36, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		Composite.add(world, [leftFence, rightFence, tulipLeftFenceL, tulipLeftFenceR, tulipRightFenceL, tulipRightFenceR]);

		// --- へその上に開閉する妨害フラップ（シャッター）を追加 ---
		const flapWidth = 60;
		const flapHeight = 8;
		const flapX = GAME_WIDTH / 2 + globalXOffset;
		const flapClosedY = 540; // 閉じたとき（若干 startChucker の上）
		const flapOpenY = 500;   // 開いたとき
		const flap = Bodies.rectangle(flapX, flapOpenY, flapWidth, flapHeight, { isStatic: true, label: 'flap', render: { fillStyle: '#c0392b' } });
		Composite.add(world, flap);
		let flapTargetY = flapOpenY;
		let flapOpen = true;
		// toggle every 0.5s
		setInterval(() => { flapOpen = !flapOpen; flapTargetY = flapOpen ? flapOpenY : flapClosedY; }, 500);

		// --- ゲームロジック ---

		// ボタンを押し続けている間、玉を落下させる
		function startDropping() {
			if (dropInterval) return;
			dropInterval = setInterval(dropBall, 100);
		}

		function stopDropping() {
			clearInterval(dropInterval);
			dropInterval = null;
		}

		function dropBall() {
			const randomX = GAME_WIDTH / 2 + globalXOffset + (Math.random() - 0.5) * 100; // ★変更点
			const ball = Bodies.circle(randomX, -20, 7, {
				label: 'ball', restitution: 0.9, friction: 0.05,
				render: { fillStyle: '#ecf0f1' }
			});
			Composite.add(world, ball);
			// カウント更新
			totalDrops++;
			updateStats();
		}

		dropButton.addEventListener('mousedown', startDropping);
		dropButton.addEventListener('mouseup', stopDropping);
		dropButton.addEventListener('mouseleave', stopDropping);
		dropButton.addEventListener('touchstart', (e) => { e.preventDefault(); startDropping(); });
		dropButton.addEventListener('touchend', (e) => { e.preventDefault(); stopDropping(); });

		// スペースキーで玉を投下（押下で開始、離して停止）
		let spaceDown = false;
		window.addEventListener('keydown', (e) => {
			if (e.code === 'Space') {
				e.preventDefault();
				if (!spaceDown) { spaceDown = true; startDropping(); }
			}
		});
		window.addEventListener('keyup', (e) => {
			if (e.code === 'Space') {
				e.preventDefault();
				spaceDown = false; stopDropping();
			}
		});


		// ヘルパー: 上から入ったかどうかを判定
		function isTopHit(ball, target) {
			if (!ball || !target) return false;
			// ボールが下向きに移動していること（閾値あり）
			if (!ball.velocity || ball.velocity.y <= 0.2) return false;
			// ボールの重心がターゲットの上方にあること（余裕を持たせる）
			if (!(ball.position.y < target.position.y - 6)) return false;
			return true;
		}

		// 当たり判定（上から入った場合のみ当たりとする）
		Events.on(engine, 'collisionStart', (event) => {
			event.pairs.forEach(pair => {
				const { bodyA, bodyB } = pair;
				let ball, other;
				if (bodyA.label === 'ball') { ball = bodyA; other = bodyB; }
				else if (bodyB.label === 'ball') { ball = bodyB; other = bodyA; }
				else return;

				switch (other.label) {
					case 'windmill':
						// 風車に当たったら強く弾く
						const dx = ball.position.x - other.position.x;
						const dy = ball.position.y - other.position.y;
						const len = Math.sqrt(dx * dx + dy * dy) || 1;
						const forceScale = 0.2; // 調整値: 力の大きさ（増加）
						const upBias = -0.04; // 上向きバイアスでふっとばし感を強める
						Body.applyForce(ball, ball.position, { x: (dx / len) * forceScale, y: (dy / len) * forceScale + upBias });
						break;
					case 'startChucker':
						// 上から入った場合のみ当たり扱いにする
						if (isTopHit(ball, other)) {
							handleHit(ball, '#e67e22');
							orangeHits++;
							updateStats();
						}
						break;
					case 'tulip':
						if (isTopHit(ball, other)) {
							handleHit(ball, '#3498db');
							blueHits++;
							updateStats();
						}
						break;
				}
			});
		});

		function updateStats() {
			const orangeRatio = totalDrops === 0 ? 0 : Math.round((orangeHits / totalDrops) * 1000) / 10;
			const blueRatio = totalDrops === 0 ? 0 : Math.round((blueHits / totalDrops) * 1000) / 10;
			statsEl.textContent = `投入:${totalDrops}  オレンジ:${orangeHits}(${orangeRatio}%)  青:${blueHits}(${blueRatio}%)`;
		}

		// 画面外に落ちた玉を消す
		Events.on(engine, 'afterUpdate', () => {
			Composite.allBodies(world).forEach(body => {
				if (body.label === 'ball' && body.position.y > GAME_HEIGHT + 50) {
					Composite.remove(world, body);
				}
			});
		});

		// センサーにヒットした玉を色を変えてから消す演出
		function handleHit(ball, color) {
			if (!ball.isHitting) {
				ball.isHitting = true; // 多重ヒット防止
				ball.render.fillStyle = color;
				setTimeout(() => {
					Composite.remove(world, ball);
				}, 100); // すぐに消す
			}
		}

		function showMessage(text, duration = 2000) {
			messageBox.textContent = text;
			messageBox.style.visibility = 'visible';
			setTimeout(() => { messageBox.style.visibility = 'hidden'; }, duration);
		}
	</script>
</body>

</html>