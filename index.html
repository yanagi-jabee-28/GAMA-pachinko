<!DOCTYPE html>
<html>

<head>
	<title>Matter.js パチンコシミュレーター</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" href="/favicon.ico">
	<link rel="stylesheet" href="src/css/style.css">
</head>


<body>
	<nav style="position:fixed;left:12px;top:12px;z-index:999;">
		<a href="../index.html"
			style="background:#fff;padding:8px 10px;border-radius:6px;text-decoration:none;color:#333;box-shadow:0 2px 6px rgba(0,0,0,0.12);">ポータルへ戻る</a>
	</nav>
	<div class="game-container">
		<canvas id="pachinko-canvas"></canvas>
		<div class="ui-container">
			<div class="message-box" id="message-box">メッセージ</div>
			<button id="drop-button">落下</button>
		</div>
	</div>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
	<script src="src/js/config.js"></script>
	<script src="src/js/audio.js"></script>
	<script>
		// --- Matter.js モジュールの準備 ---
		const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;

		// --- ゲーム設定 ---
		const GAME_WIDTH = 450;
		const GAME_HEIGHT = 700;
		const ENABLE_WALL_MISS = true; // ★追加: 壁に当たった時にハズレにするかどうかのフラグ
		let dropInterval = null;

		// --- UI要素の取得 ---
		const dropButton = document.getElementById('drop-button');
		const messageBox = document.getElementById('message-box');

		// 投下数 / 役物ヒット数カウンタ
		let totalDrops = 0;
		let orangeHits = 0; // startChucker
		let blueHits = 0;   // tulip
		let missHits = 0;   // ハズレ（missZone）

		// 比率表示要素を作る
		const statsEl = document.createElement('div');
		statsEl.style.pointerEvents = 'none';
		statsEl.style.position = 'absolute';
		statsEl.style.bottom = '20px';
		statsEl.style.right = '20px';
		statsEl.style.padding = '6px 10px';
		statsEl.style.background = 'rgba(0,0,0,0.6)';
		statsEl.style.color = 'white';
		statsEl.style.borderRadius = '6px';
		statsEl.style.fontSize = '14px';
		statsEl.textContent = '投入:0  当たり:0  比率:0%';
		document.querySelector('.game-container').appendChild(statsEl);

		// --- Matter.js エンジンの初期化 ---
		const engine = Engine.create({
			gravity: { y: (window.CONFIG && window.CONFIG.GRAVITY_Y) ?? 0.6 }
		});
		const world = engine.world;

		const render = Render.create({
			canvas: document.getElementById('pachinko-canvas'),
			engine: engine,
			options: {
				width: GAME_WIDTH,
				height: GAME_HEIGHT,
				wireframes: false,
				background: 'transparent'
			}
		});
		Render.run(render);
		const runner = Runner.create();
		Runner.run(runner, engine);

		// --- 壁の作成（床なし） ---
		const wallOptions = { isStatic: true, render: { visible: false } };
		Composite.add(world, [
			Bodies.rectangle(GAME_WIDTH, GAME_HEIGHT / 2, 20, GAME_HEIGHT, wallOptions), // 右
			Bodies.rectangle(0, GAME_HEIGHT / 2, 20, GAME_HEIGHT, wallOptions)      // 左
		]);

		// 左右の壁を左右対称に再配置（中央基準）
		const guideWallOffset = (window.CONFIG && window.CONFIG.GUIDE_WALL_OFFSET) || 30;
		const guideAngle = (window.CONFIG && window.CONFIG.GUIDE_WALL_ANGLE) || 0.2;
		const centerX0 = GAME_WIDTH / 2; // 純粋な中央基準
		Composite.add(world, [
			Bodies.rectangle(centerX0 - guideWallOffset, 450, 10, 500, { isStatic: true, angle: -guideAngle, render: { fillStyle: '#95a5a6' }, label: 'wall' }),
			Bodies.rectangle(centerX0 + guideWallOffset, 450, 10, 500, { isStatic: true, angle: guideAngle, render: { fillStyle: '#95a5a6' }, label: 'wall' })
		]);


		// --- 釘の森を生成 (中央揃えに調整) ---
		const pegs = [];
		// 配置済み位置の記録（Body を作る前に重なりを避けるために使う）
		const selectedPositions = [];
		const pegOptions = {
			isStatic: true, label: 'peg', restitution: 0.8, friction: 0.05,
			render: { fillStyle: '#bdc3c7' }
		};

		const spacing = (window.CONFIG && window.CONFIG.PEG_SPACING) || 35;

		// チューリップ上部の矩形除外（釘が重なりやすい場所を広めに取り除く）
		var exclusionRects = [
			{ x: 120, y: 410, w: 90, h: 60 }, // 左チューリップ上
			{ x: GAME_WIDTH - 120, y: 410, w: 90, h: 60 } // 右チューリップ上
		];
		// 画面内上部に追加の釘行（CONFIG.TOP_ROW_YS）
		{
			const topRows = (window.CONFIG && window.CONFIG.TOP_ROW_YS) || [20, 50];
			const minDist = 12;
			topRows.forEach((topY, idx) => {
				const cols = (idx % 2 === 0) ? 9 : 8; // 交互に列数を変えて中央揃え
				const rowWidth = (cols - 1) * spacing;
				const xOffset = (GAME_WIDTH - rowWidth) / 2;
				for (let col = 0; col < cols; col++) {
					const x = xOffset + col * spacing; // ジッタ無し
					let tooClose = false;
					for (let rect of exclusionRects) {
						if (Math.abs(x - rect.x) < rect.w / 2 && Math.abs(topY - rect.y) < rect.h / 2) { tooClose = true; break; }
					}
					for (let pos of selectedPositions) {
						const dx = pos.x - x;
						const dy = pos.y - topY;
						if (dx * dx + dy * dy < minDist * minDist) { tooClose = true; break; }
					}
					if (!tooClose) { selectedPositions.push({ x, y: topY }); pegs.push(Bodies.circle(x, topY, 4, pegOptions)); }
				}
			});
		}

		const rows = (window.CONFIG && window.CONFIG.PEG_ROWS) || 18;

		// スタックしやすい領域（風車・へそ・チューリップ周辺）は釘を減らす / ジッタを入れる
		const cx = GAME_WIDTH / 2;
		const exclusionZones = [
			{ x: cx, y: 320, r: 70 }, // 中央風車周辺
			{ x: cx - 80, y: 320, r: 50 }, // 左風車
			{ x: cx + 80, y: 320, r: 50 }, // 右風車
			{ x: cx, y: 580, r: 60 }, // startChucker 上（半径拡大）
			{ x: 120, y: 450, r: 48 }, // tulip left（半径拡大）
			{ x: GAME_WIDTH - 120, y: 450, r: 48 } // tulip right（半径拡大）
		];
		for (let row = 0; row < rows; row++) {
			const y = 80 + row * 30;

			const isEven = (row % 2 === 0);
			const cols = isEven ? 8 : 9;
			const rowWidth = (cols - 1) * spacing;
			const xOffset = (GAME_WIDTH - rowWidth) / 2; // 中央揃え

			// ジッタを使わずに中央揃えで配置（左右対称性は xOffset と cols により保たれる）
			const minDist = 12;
			for (let col = 0; col < cols; col++) {
				const x = xOffset + col * spacing;

				// チューリップ上部の矩形除外チェック
				let skip = false;
				for (let rect of exclusionRects) {
					if (Math.abs(x - rect.x) < rect.w / 2 && Math.abs(y - rect.y) < rect.h / 2) { skip = true; break; }
				}
				if (skip) continue;
				// 除外ゾーンに入る場合はスキップ
				for (let z of exclusionZones) {
					const dx = x - z.x;
					const dy = y - z.y;
					if (dx * dx + dy * dy < z.r * z.r) { skip = true; break; }
				}
				if (skip) continue;

				// selectedPositions で衝突チェック
				let tooClose = false;
				for (let pos of selectedPositions) {
					const dx = pos.x - x;
					const dy = pos.y - y;
					if (dx * dx + dy * dy < minDist * minDist) { tooClose = true; break; }
				}
				if (!tooClose) { selectedPositions.push({ x, y }); pegs.push(Bodies.circle(x, y, 4, pegOptions)); }
			}
		}
		Composite.add(world, pegs);

		// 役物周りの追加ペグ（左右対称） - 直接入りづらくするガードを追加
		// 中央のstartChucker上部に小さなバリアを作る
		const extraPegs = [];
		const centerX = GAME_WIDTH / 2;
		const barrierY = 540; // startChucker (y=570) の少し上
		const barrierSpacing = 30;
		// 中央バリア: 中央はあえて空けて通路を残す
		for (let i = -1; i <= 1; i++) {
			if (i === 0) continue; // 真ん中は開ける
			extraPegs.push(Bodies.circle(centerX + i * barrierSpacing, barrierY, 5, pegOptions));
		}
		// 以前追加した密集バリアは強すぎたため削除（入らない問題の原因）
		// 代わりに中央バリアを少し散らして隙間を残す
		for (let i = -2; i <= 2; i++) {
			if (i % 2 === 0) continue; // 間隔を空ける
			extraPegs.push(Bodies.circle(centerX + i * (barrierSpacing / 1.5), barrierY + 10, 5, pegOptions));
		}

		// チューリップ周りの左右に小さなガードを置く
		const tulipY = 430; // tulip の少し上
		const tulipLeftX = 120;
		const tulipRightX = GAME_WIDTH - 120;
		const tulipGuardOffset = 18;
		extraPegs.push(Bodies.circle(tulipLeftX - tulipGuardOffset, tulipY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipLeftX + tulipGuardOffset, tulipY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipRightX - tulipGuardOffset, tulipY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipRightX + tulipGuardOffset, tulipY, 5, pegOptions));
		// チューリップ周辺の追加ディフレクタ: 少し外側へ移動して入口を確保
		const tulipUpperY = tulipY - 20;
		extraPegs.push(Bodies.circle(tulipLeftX - 40, tulipUpperY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipLeftX + 40, tulipUpperY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipRightX - 40, tulipUpperY, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipRightX + 40, tulipUpperY, 5, pegOptions));
		// 外側のガードは少しだけ外側に置いて、完全に塞がない
		extraPegs.push(Bodies.circle(tulipLeftX - 70, tulipY - 8, 5, pegOptions));
		extraPegs.push(Bodies.circle(tulipRightX + 70, tulipY - 8, 5, pegOptions));

		// extraPegs のうち、チューリップ入口近辺にスタックしやすいものは除外する
		const filteredExtraPegs = extraPegs.filter(p => {
			const px = p.position.x;
			const py = p.position.y;
			// 左チューリップ入口付近の除外矩形
			const leftX = tulipLeftX;
			if (px > leftX + 8 && px < leftX + 54 && py > tulipY - 10 && py < tulipY + 30) return false;
			// 右チューリップ入口付近の除外矩形
			const rightX = tulipRightX;
			if (px > rightX - 54 && px < rightX - 8 && py > tulipY - 10 && py < tulipY + 30) return false;
			return true;
		});
		Composite.add(world, filteredExtraPegs);

		// --- 左右の回転ゲート（ピンボール風） ---
		const gates = [];
		// より役物の上部に配置して妨害する位置にする
		const gateY = 520; // 役物上部へ移動
		const gateOffsetX = 44;
		// ゲートは回転して閉じる（角度で制御）。長めにして遮りやすくする
		// pivot をゲートの端に置くため、ボディの中心位置を pivot から半分のオフセットで計算して作成する
		const gateLength = 60;
		const gateHalf = gateLength / 2;
		// left pivot
		const leftPivot = { x: (GAME_WIDTH / 2) - gateOffsetX, y: gateY };
		const leftCenter = { x: leftPivot.x + Math.sin(-1.0) * gateHalf, y: leftPivot.y - Math.cos(-1.0) * gateHalf };
		const leftGate = Bodies.rectangle(leftCenter.x, leftCenter.y, 10, gateLength, { isStatic: true, label: 'gate', render: { fillStyle: '#c0392b' } });
		Body.setAngle(leftGate, -1.0);
		// right pivot
		const rightPivot = { x: (GAME_WIDTH / 2) + gateOffsetX, y: gateY };
		const rightCenter = { x: rightPivot.x + Math.sin(1.0) * gateHalf, y: rightPivot.y - Math.cos(1.0) * gateHalf };
		const rightGate = Bodies.rectangle(rightCenter.x, rightCenter.y, 10, gateLength, { isStatic: true, label: 'gate', render: { fillStyle: '#c0392b' } });
		Body.setAngle(rightGate, 1.0);
		Composite.add(world, [leftGate, rightGate]);
		// openAngle は斜め上、closedAngle はほぼ水平に近づけて入口を塞ぐ
		// open/closed の角度を再調整して上方向に大きく開くようにする
		const OPEN_ANGLE = (window.CONFIG && window.CONFIG.GATE_OPEN_ANGLE) || 2.3;
		const CLOSED_ANGLE = (window.CONFIG && window.CONFIG.GATE_CLOSED_ANGLE) || 0.3;
		// 再配置：センター位置を OPEN_ANGLE に合わせて再計算
		const leftCenter2 = { x: leftPivot.x + Math.sin(-OPEN_ANGLE) * gateHalf, y: leftPivot.y - Math.cos(-OPEN_ANGLE) * gateHalf };
		Body.setPosition(leftGate, leftCenter2);
		Body.setAngle(leftGate, -OPEN_ANGLE);
		const rightCenter2 = { x: rightPivot.x + Math.sin(OPEN_ANGLE) * gateHalf, y: rightPivot.y - Math.cos(OPEN_ANGLE) * gateHalf };
		Body.setPosition(rightGate, rightCenter2);
		Body.setAngle(rightGate, OPEN_ANGLE);
		gates.push({ body: leftGate, pivot: leftPivot, length: gateLength, targetAngle: -OPEN_ANGLE, closedAngle: -CLOSED_ANGLE, openAngle: -OPEN_ANGLE });
		gates.push({ body: rightGate, pivot: rightPivot, length: gateLength, targetAngle: OPEN_ANGLE, closedAngle: CLOSED_ANGLE, openAngle: OPEN_ANGLE });

		// asymmetric gate cycle: keep "open" time shorter than closed time
		const GATE_OPEN_MS = (window.CONFIG && window.CONFIG.GATE_OPEN_MS) || 800;   // 短く開く時間（ms）
		const GATE_CLOSED_MS = (window.CONFIG && window.CONFIG.GATE_CLOSED_MS) || 300; // 閉じている時間（ms）
		function setGatesOpen(open) {
			gates.forEach(g => { g.targetAngle = open ? g.openAngle : g.closedAngle; });
		}
		function startGateCycle() {
			// start by ensuring gates are open
			setGatesOpen(true);
			setTimeout(() => {
				// close after short open period
				setGatesOpen(false);
				// schedule next open after closed period
				setTimeout(startGateCycle, GATE_CLOSED_MS);
			}, GATE_OPEN_MS);
		}
		startGateCycle();

		// --- 画面中央あたりの "外れゾーン"（センサー）を追加 ---
		// ここを通過したら玉は即時消去される
		const missZoneWidth = 40;
		const missZoneHeight = 5;
		const missZone = Bodies.rectangle(GAME_WIDTH / 2, 200, missZoneWidth, missZoneHeight, {
			isStatic: true, isSensor: true, label: 'missZone', render: { fillStyle: 'rgba(192,57,43,0.35)', strokeStyle: 'rgba(192,57,43,0.7)' }
		});
		Composite.add(world, missZone);

		// --- 風車（回転障害）の作成: 複合ボディを回転させて玉を妨害 ---
		const windmills = [];
		function createWindmill(cx, cy, blades = 4, radius = 70, bladeW = 8, bladeH = 60, speed = 0.06, color = '#f39c12') {
			const parts = [];
			// ハブ
			const hub = Bodies.circle(cx, cy, 6, { isStatic: true, restitution: 0.8, render: { fillStyle: '#7f8c8d' } });
			parts.push(hub);
			for (let i = 0; i < blades; i++) {
				const angle = (i / blades) * Math.PI * 2;
				const bx = cx + Math.cos(angle) * (radius / 2);
				const by = cy + Math.sin(angle) * (radius / 2);
				const blade = Bodies.rectangle(bx, by, bladeH, bladeW, { isStatic: true, restitution: 0.8, render: { fillStyle: color } });
				Body.setAngle(blade, angle);
				parts.push(blade);
			}
			const compound = Body.create({ parts: parts, isStatic: true, label: 'windmill' });
			Composite.add(world, compound);
			windmills.push({ body: compound, speed });
		}

		// 風車を左右対称に配置（設定から）。回転方向は従来と逆に。
		const centerXWind = GAME_WIDTH / 2;
		const WM = (window.CONFIG && window.CONFIG.WINDMILL) || {};
		const ENABLE_CENTER_WINDMILL = (window.CONFIG && window.CONFIG.ENABLE_CENTER_WINDMILL) || false;
		const baseSpeed = (WM.baseSpeed) || 0.08;
		const leftSpeed = baseSpeed * (WM.leftCW ? 1 : -1);
		const rightSpeed = baseSpeed * (WM.rightCW ? 1 : -1);
		const centerSpeed = baseSpeed * (WM.centerCW ? 1 : -1);
		createWindmill(centerXWind - 80, 320, WM.blades || 4, WM.radius || 40, WM.bladeW || 8, WM.bladeH || 40, leftSpeed, WM.color || '#f39c12');
		createWindmill(centerXWind + 80, 320, WM.blades || 4, WM.radius || 40, WM.bladeW || 8, WM.bladeH || 40, rightSpeed, WM.color || '#f39c12');
		if (ENABLE_CENTER_WINDMILL) {
			createWindmill(centerXWind, 470, WM.blades || 4, WM.radius || 40, 6, WM.bladeH || 40, centerSpeed, WM.color || '#f39c12');
			if (windmills.length) windmills[windmills.length - 1].isCenter = true;
		}

		// 回転を毎フレーム適用
		Events.on(engine, 'beforeUpdate', () => {
			windmills.forEach(w => {
				Body.setAngle(w.body, w.body.angle + w.speed);
			});


			// 回転ゲートの角度補間（存在する場合）
			if (typeof gates !== 'undefined') {
				gates.forEach(g => {
					const ang = g.body.angle;
					const d = g.targetAngle - ang;
					if (Math.abs(d) > 0.001) {
						const newAng = ang + d * 0.25;
						// pivot を回転軸として中心位置を再計算
						const half = g.length / 2;
						const cx = g.pivot.x - Math.sin(newAng) * half;
						const cy = g.pivot.y + Math.cos(newAng) * half;
						Body.setPosition(g.body, { x: cx, y: cy });
						Body.setAngle(g.body, newAng);
					}
				});
			}
		});

		// 中央風車の自動反転は CONFIG ベースの挙動に任せる（setInterval による自動反転を削除）

		// --- 役物（やくもの）の作成 ---
		// startChucker を少し小さく下げる
		const startChucker = Bodies.rectangle(GAME_WIDTH / 2, 580, 36, 10, { // ★変更点
			isStatic: true, isSensor: true, label: 'startChucker', render: { fillStyle: '#e67e22' }
		});
		// チューリップ幅を縮小
		const tulipLeft = Bodies.rectangle(120, 450, 32, 10, { // ★変更点
			isStatic: true, isSensor: true, label: 'tulip', render: { fillStyle: '#3498db' }
		});
		const tulipRight = Bodies.rectangle(GAME_WIDTH - 120, 450, 32, 10, { // ★変更点
			isStatic: true, isSensor: true, label: 'tulip', render: { fillStyle: '#3498db' }
		});
		Composite.add(world, [startChucker, tulipLeft, tulipRight]);

		// 役物左右のフェンス（ガイド）を追加して横からの侵入を物理的に防ぐ
		const fenceHeight = 40;
		const fenceThickness = 6;
		// startChucker の左右フェンス
		const fenceOffsetX = 26;
		const leftFence = Bodies.rectangle((GAME_WIDTH / 2) - fenceOffsetX, 560, fenceThickness, fenceHeight, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		const rightFence = Bodies.rectangle((GAME_WIDTH / 2) + fenceOffsetX, 560, fenceThickness, fenceHeight, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		// チューリップ左右にもフェンス（入口の幅を限定）
		const tulipFenceY = 450;
		const tulipFenceOffset = 22;
		const tulipLeftFenceL = Bodies.rectangle(tulipLeft.position.x - tulipFenceOffset, tulipFenceY, fenceThickness, 36, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		const tulipLeftFenceR = Bodies.rectangle(tulipLeft.position.x + tulipFenceOffset, tulipFenceY, fenceThickness, 36, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		const tulipRightFenceL = Bodies.rectangle(tulipRight.position.x - tulipFenceOffset, tulipFenceY, fenceThickness, 36, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		const tulipRightFenceR = Bodies.rectangle(tulipRight.position.x + tulipFenceOffset, tulipFenceY, fenceThickness, 36, { isStatic: true, render: { fillStyle: '#7f8c8d' } });
		Composite.add(world, [leftFence, rightFence, tulipLeftFenceL, tulipLeftFenceR, tulipRightFenceL, tulipRightFenceR]);

		// (以前あった flap は削除されました)

		// --- ゲームロジック ---

		// ★追加: 破片を生成する関数 (修正版)
		function createDebris(x, y, color) {
			const debrisCount = 8;
			const debris = [];
			for (let i = 0; i < debrisCount; i++) {
				const angle = Math.random() * Math.PI * 2;
				const speed = 3 + Math.random() * 4;
				const particle = Bodies.circle(x, y, 1 + Math.random() * 2, {
					label: 'debris',
					friction: 0.05,
					restitution: 0.4,
					render: { fillStyle: color },
					// ★変更点: 破片同士や他のオブジェクトと衝突しないように設定
					collisionFilter: {
						group: -1
					}
				});
				Body.setVelocity(particle, {
					x: Math.cos(angle) * speed,
					y: Math.sin(angle) * speed - 2
				});
				debris.push(particle);
			}

			Composite.add(world, debris);
			try { if (window.AudioBus) { AudioBus.sfxSimple({ freq: 200, type: 'triangle', gain: 0.15, dur: 0.04 }); } } catch (e) { }

			// ★変更点: 0.2秒後に破片を消去する
			setTimeout(() => {
				Composite.remove(world, debris);
			}, 200);
		}

		// ボタンを押し続けている間、玉を落下させる
		function startDropping() {
			if (dropInterval) return;
			dropInterval = setInterval(dropBall, (window.CONFIG && window.CONFIG.DROP_INTERVAL_MS) || 80);
		}

		function stopDropping() {
			clearInterval(dropInterval);
			dropInterval = null;
		}

		// dropBall: optional options { fromBlue: boolean }
		function dropBall(options = {}) {
			const randomX = GAME_WIDTH / 2 + (Math.random() - 0.5) * 100; // ★変更点
			const color = options.isNavy ? '#ffd700' : (options.fromBlue ? '#3498db' : '#ecf0f1');
			const ball = Bodies.circle(randomX, -20, (window.CONFIG && window.CONFIG.BALL_RADIUS) || 5, {
				label: 'ball', restitution: 0.9, friction: 0.05,
				render: { fillStyle: color }
			});
			if (options.fromBlue) {
				ball.isFromBlue = true;
				// 青球はハズレ判定を無効にする
				ball.isImmuneToMiss = true;
			}
			if (options.isNavy) {
				ball.isNavy = true;
				ball.isImmuneToMiss = true;
				ball.isFromBlue = true; // 紺碧も青扱い
			}
			Composite.add(world, ball);
			// カウント更新（再投下は totalDrops に含めるかは設計次第だが、ここでは含める）
			totalDrops++;
			updateStats();
		}

		dropButton.addEventListener('mousedown', startDropping);
		dropButton.addEventListener('mouseup', stopDropping);
		dropButton.addEventListener('mouseleave', stopDropping);
		dropButton.addEventListener('touchstart', (e) => { e.preventDefault(); startDropping(); });
		dropButton.addEventListener('touchend', (e) => { e.preventDefault(); stopDropping(); });

		// スペースキーで玉を投下（押下で開始、離して停止）
		let spaceDown = false;
		window.addEventListener('keydown', (e) => {
			if (e.code === 'Space') {
				e.preventDefault();
				if (!spaceDown) { spaceDown = true; startDropping(); }
			}
		});
		window.addEventListener('keyup', (e) => {
			if (e.code === 'Space') {
				e.preventDefault();
				spaceDown = false; stopDropping();
			}
		});


		// ヘルパー: 上から入ったかどうかを判定
		function isTopHit(ball, target) {
			if (!ball || !target) return false;
			// ボールが下向きに移動していること（閾値あり）
			if (!ball.velocity || ball.velocity.y <= 0.2) return false;
			// ボールの重心がターゲットの上方にあること（余裕を持たせる）
			if (!(ball.position.y < target.position.y - 6)) return false;
			return true;
		}

		// 当たり判定（上から入った場合のみ当たりとする）
		Events.on(engine, 'collisionStart', (event) => {
			event.pairs.forEach(pair => {
				const { bodyA, bodyB } = pair;
				let ball, other;
				if (bodyA.label === 'ball') { ball = bodyA; other = bodyB; }
				else if (bodyB.label === 'ball') { ball = bodyB; other = bodyA; }
				else return;

				switch (other.label) {
					case 'windmill':
						// 風車に当たったら強く弾く
						const dx = ball.position.x - other.position.x;
						const dy = ball.position.y - other.position.y;
						const len = Math.sqrt(dx * dx + dy * dy) || 1;
						const forceScale = 0.2; // 調整値: 力の大きさ（増加）
						const upBias = -0.04; // 上向きバイアスでふっとばし感を強める
						Body.applyForce(ball, ball.position, { x: (dx / len) * forceScale, y: (dy / len) * forceScale + upBias });
						break;
					case 'startChucker':
						// 上から入った場合のみ当たり扱いにする
						if (isTopHit(ball, other)) {
							// 白でも青でも当たり扱いにする
							// カウント更新
							orangeHits++;
							updateStats();
							// ★変更点: 砕ける演出を追加
							createDebris(ball.position.x, ball.position.y, '#e67e22');
							try { Composite.remove(world, ball); } catch (e) { }
							try { if (window.AudioBus && window.CONFIG) { AudioBus.sfxSimple(window.CONFIG.SFX.chucker); } } catch (e) { }
							// 黄金として再投入する
							setTimeout(() => { dropBall({ fromBlue: true, isNavy: true }); }, 200);
						}
						break;
					case 'tulip':
						if (isTopHit(ball, other)) {
							// ★変更点: 砕ける演出を追加
							createDebris(ball.position.x, ball.position.y, '#3498db');
							// チューリップに入ったら必ず回収して再投下する
							try { Composite.remove(world, ball); } catch (e) { }
							blueHits++;
							updateStats();
							try { if (window.AudioBus && window.CONFIG) { AudioBus.sfxSimple(window.CONFIG.SFX.tulip); } } catch (e) { }
							// 再投下オプション: 既に金（isNavy）なら金で再投下
							const opts = { fromBlue: true };
							if (ball.isNavy) { opts.isNavy = true; }
							setTimeout(() => { dropBall(opts); }, 200);
						}
						break;
					case 'wall':
						// ★追加: 壁でのハズレ判定
						if (!ENABLE_WALL_MISS || ball.isImmuneToMiss) {
							break;
						}
						createDebris(ball.position.x, ball.position.y, ball.render.fillStyle);
						try { if (window.AudioBus && window.CONFIG) { AudioBus.sfxSimple(window.CONFIG.SFX.miss); } } catch (e) { }
						try { Composite.remove(world, ball); } catch (e) { }
						missHits++;
						updateStats();
						break;
					case 'missZone':
						// ハズレゾーン: 免疫がある玉は無視
						if (ball.isImmuneToMiss) { break; }
						// ★変更点: 玉を消す代わりに砕ける演出を追加
						createDebris(ball.position.x, ball.position.y, ball.render.fillStyle);
						try { if (window.AudioBus && window.CONFIG) { AudioBus.sfxSimple(window.CONFIG.SFX.miss); } } catch (e) { }
						try { Composite.remove(world, ball); } catch (e) { }
						missHits++;
						updateStats();
						break;
				}
			});
		});

		function updateStats() {
			const orangeRatio = totalDrops === 0 ? 0 : Math.round((orangeHits / totalDrops) * 1000) / 10;
			const blueRatio = totalDrops === 0 ? 0 : Math.round((blueHits / totalDrops) * 1000) / 10;
			statsEl.textContent = `投入:${totalDrops}  オレンジ:${orangeHits}(${orangeRatio}%)  青:${blueHits}(${blueRatio}%)  ハズレ:${missHits}`;
		}

		// スイープ判定で「上からの正式ヒット」を保証 + 画面外の玉を回収 + 前位置を記録
		Events.on(engine, 'afterUpdate', () => {
			// すり抜け防止: 前フレーム位置から現在位置までの線分がターゲット上辺を跨いだかを判定
			const targets = [
				{ body: startChucker, type: 'startChucker' },
				{ body: tulipLeft, type: 'tulip' },
				{ body: tulipRight, type: 'tulip' }
			];
			const bodies = Composite.allBodies(world);
			for (const b of bodies) {
				if (b.label !== 'ball') continue;
				if (b.isHitting) continue; // 既に処理中
				const prev = b.lastPos || b.position;
				const curr = b.position;
				if ((curr.y - prev.y) <= 0.05) { b.lastPos = { x: curr.x, y: curr.y }; continue; } // 下向きでなければスキップ

				for (const t of targets) {
					const tb = t.body; if (!tb) continue;
					const topY = tb.bounds.min.y; // 上辺Y
					// 上辺を跨いだか（prevは上/ currは下）
					if (prev.y < topY && curr.y >= topY) {
						// 交点Xを線形補間で求める
						const dy = (curr.y - prev.y) || 1e-6;
						const tRatio = (topY - prev.y) / dy;
						const xCross = prev.x + (curr.x - prev.x) * tRatio;
						// 横幅判定（半径ぶんの余裕を持たせる）
						const margin = 3;
						const minX = tb.bounds.min.x - margin;
						const maxX = tb.bounds.max.x + margin;
						if (xCross >= minX && xCross <= maxX) {
							// 正式ヒットとして処理（collisionStart と同等の分岐）
							b.isHitting = true;
							if (t.type === 'startChucker') {
								orangeHits++;
								updateStats();
								createDebris(b.position.x, b.position.y, '#e67e22');
								try { Composite.remove(world, b); } catch (e) { }
								setTimeout(() => { dropBall({ fromBlue: true, isNavy: true }); }, 200);
							} else { // tulip
								blueHits++;
								updateStats();
								createDebris(b.position.x, b.position.y, '#3498db');
								const opts = { fromBlue: true };
								if (b.isNavy) opts.isNavy = true;
								try { Composite.remove(world, b); } catch (e) { }
								setTimeout(() => { dropBall(opts); }, 200);
							}
							break; // 1ターゲット処理で抜ける
						}
					}
				}
				// 画面外に落ちた玉を回収
				if (b.position.y > GAME_HEIGHT + 50) {
					try { Composite.remove(world, b); } catch (e) { }
				}
				// 前位置を記録
				b.lastPos = { x: curr.x, y: curr.y };
			}
		});

		// センサーにヒットした玉を色を変えてから消す演出（通常）
		function handleHit(ball, color) {
			if (!ball || ball.isHitting) return;
			ball.isHitting = true; // 多重ヒット防止
			ball.render.fillStyle = color;
			setTimeout(() => { Composite.remove(world, ball); }, 100);
		}

		// チューリップに入った玉: 青扱いにしてリドロップする
		function handleTulipHit(ball) {
			if (!ball || ball.isHitting) return;
			ball.isHitting = true;
			// 青として見た目を変える
			ball.isFromBlue = true;
			ball.render.fillStyle = '#3498db';
			// 画面上からは即座に消す（ただし再投下の遅延は維持）
			try { Composite.remove(world, ball); } catch (e) { }
			setTimeout(() => { dropBall({ fromBlue: true }); }, 200);
		}

		function showMessage(text, duration = 2000) {
			messageBox.textContent = text;
			messageBox.style.visibility = 'visible';
			setTimeout(() => { messageBox.style.visibility = 'hidden'; }, duration);
		}
	</script>
</body>

</html>